---
layout: post
title: "JNI"
subtitle: 'java调用c++'
author: "zhutao"
header-style: text
tags:
  - cpp
---

### JNI概念

JNI是Java Native Interface的缩写，它提供了若干的[API](https://baike.baidu.com/item/API/10154)实现了Java和其他语言的通信（主要是[C](https://baike.baidu.com/item/C/7252092)&[C++](https://baike.baidu.com/item/C%2B%2B)）.这是百度百科上说的.通俗来说,就是JAVA调用C/C++函数的接口.如果你要想调用C系列的函数,你就必须遵守这样的约定.

### JNI接口都长什么样?

```java
/*
 * 文件名：NativeDemo.java
 */
public  class NativeDemo {
	{
		/**
		 * 系统加载其他的语言的函数
		 */
		System.load("path/to/*.so");
	}
	/**
	 * 就这个native关键字.标记了这个接口,看起来像是abstract
	 */
	public native void sayHello();
	
	
	public static void main(String[] args) {
		new NativeDemo().sayHello();
	}
}
```

### jni.h是什么?

它实际上就存在%JAVA_HOME%\bin\include下面的一个文件,另外还有个%JAVA_HOME%\bin\include\darwin下的jni_md.h.

这东西不说其他的作用,我也不清楚,只知道它里面存储了大量的函数和对象,它有个很好的方法就是通过native接口名,获取C函数.

打个比方类似如下:

`public static String getCMethod(String javaMethodName);`

它可以根据你的java接口,找到C函数并调用.

但这就意味着,你不能在C里随意写函数名,因为如果你写的java方法叫native aaa();C函数也叫aaa();但jni.h通过getCMethod(String javaMethodName)去找的结果是xxx();那这样就无法调用了.

既然不能随意写,怎么办?

没事，jdk提供了一个通过java方法生成c函数接口名的工具javah

### javah是什么?

就像java是运行main方法一样,javah就是提供具有native method的java对象的c函数接口.

dos命令如下:

```shell
javac NativeDemo.java
javah NativeDemo
```

**attention**

如果是mac环境，会报错

`Unable to locate an executable at "/Library/Java/JavaVirtualMachines/jdk-10.0.2.jdk/Contents/Home/bin/javah" (-1)`

这是因为java-mac取消了javah,直接改用javac -h代替了，直接在命令行输入

```shel
javac NativeDemo.java -h .
```

会同时生成.class和.h头文件

生成的NativeDemo.h内容如下

```cpp
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class NativeDemo */

#ifndef _Included_NativeDemo
#define _Included_NativeDemo
#ifdef __cplusplus
extern "C" {
#endif
/*
 * Class:     NativeDemo
 * Method:    sayHello
 * Signature: ()V
 */
JNIEXPORT void JNICALL Java_NativeDemo_sayHello
  (JNIEnv *, jobject);

#ifdef __cplusplus
}
#endif
#endif
```

最重要的C函数接口就是这样:JNIEXPORT void JNICALL Java_NativeDemo_sayHello(JNIEnv *, jobject);

- JNIEXPORT ：在Jni编程中所有本地语言实现Jni接口的方法前面都有一个"JNIEXPORT",这个可以看做是Jni的一个标志，至今为止没发现它有什么特殊的用处。

- void ：这个学过编程的人都知道，当然是方法的返回值了。

- JNICALL ：这个可以理解为Jni 和Call两个部分，和起来的意思就是 Jni调用XXX（后面的XXX就是JAVA的方法名）。

- Java_NativeDemo_sayHello：这个就是被上一步中被调用的部分，也就是Java中的native 方法名，这里起名字的方式比较特别，是：包名+类名+方法名。

- JNIEnv * env：这个env可以看做是Jni接口本身的一个对象，jni.h头文件中存在着大量被封装好的函数，这些函数也是Jni编程中经常被使用到的，要想调用这些函数就需要使用JNIEnv这个对象。例如：env->GetObjectClass()。（详情请查看jni.h）

- jobject obj：代表着native方法的调用者,本例即new NativeDemo();但如果native是静态的,那就是NativeDemo.class　.

也就是说，我们的native sayHello（）方法实际上是运行C的Java_NativeDemo_sayHello（）这个方法，我们是不能随意写C函数名的的，只能这样写。

接下来我们可以照着接口去写真正的函数方法了。新建NativeDemo.cpp

```cpp
#include "NativeDemo.h"
#include <iostream>

JNIEXPORT void JNICALL Java_NativeDemo_sayHello(JNIEnv *, jobject){
    using namespace std;
    cout << "hello world" << endl;
}
```

这个方法什么都没有做,就打印了一句话"Hello___________World"

然后将NativeDemo.h和NativeDemo.cpp编译运行出so文件.生成NativeDemo.so

```shell
g++ NativeDemo.cpp -I /Library/Java/JavaVirtualMachines/jdk-14.0.1.jdk/Contents/Home/include  -I /Library/Java/JavaVirtualMachines/jdk-14.0.1.jdk/Contents/Home/include/darwin -fPIC -shared -o libNativeDemo.so
```

那么现在有了这些文件

```bash
.
├── NativeDemo.class
├── NativeDemo.cpp
├── NativeDemo.h
├── NativeDemo.java
└── libNativeDemo.so
```

**Don't forget**把NativeDemo.java中`System.load("path/to/*.so");`的路径改为so文件的绝对路径。

然后就是调用java代码

```bash
$ javac NativeDemo.java
$ java NativeDemo
>>> hello world
```

OK，Java调用c++代码完成

### JNI参数传递

**字符串参数**

http://notes.maxwi.com/2017/04/20/java-jni-cpp-passing-arguments/

**一维数组参数**

https://blog.csdn.net/CV_Jason/article/details/79643532

**二维数组参数**

https://blog.csdn.net/CV_Jason/article/details/79711077?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase

### JNI固定参数说明

https://blog.csdn.net/CV_Jason/article/details/80026265

在进行JNI编程开发的时候，使用javah生成Native方法对应的Native函数声明，会发现所有的Native函数的第一个参数永远是JNIEnv指针，而第二个参数永远是jobject或jclass中的一个。JNIEnv指针指代何物？具有何种功能？jobject和jclass又有何区别？
本文简单介绍了JNI编程中`JNIEnv`、`jobject`和`jclass`这三种基本类型。

**JNIEnv**，顾名思义，指代了Java本地接口环境(*Java Native Interface Environment*），是一个JNI接口指针，指向了本地方法的一个函数表，该函数表中的每一个成员指向了一个JNI函数，本地方法通过JNI函数来访问JVM中的数据结构，详情如下图：

![](JNIEnv图解.png)

而`JNIEnv`指针在文件中的具体实现是一个包含诸多JNI函数的结构体，在C语言中该结构体的名字定义为`JNIEnv_`。局部摘要如下：

```cpp
/*
 * We use inlined functions for C++ so that programmers can write:
 *
 *    env->FindClass("java/lang/String")
 *
 * in C++ rather than:
 *
 *    (*env)->FindClass(env, "java/lang/String")
 *
 * in C.
 */

struct JNIEnv_ {
    const struct JNINativeInterface_ *functions;
#ifdef __cplusplus

    jint GetVersion() {
        return functions->GetVersion(this);
    }
    jclass DefineClass(const char *name, jobject loader, const jbyte *buf,
                       jsize len) {
        return functions->DefineClass(this, name, loader, buf, len);
    }
    ...
     jclass GetObjectClass(jobject obj) {
        return functions->GetObjectClass(this,obj);
    }
    jboolean IsInstanceOf(jobject obj, jclass clazz) {
        return functions->IsInstanceOf(this,obj,clazz);
    }

    jmethodID GetMethodID(jclass clazz, const char *name,
                          const char *sig) {
        return functions->GetMethodID(this,clazz,name,sig);
    }
    ...
 }
```

**jobject**与**jclass**通常作为JNI函数的第二个参数，当所声明Native方法是静态方法时，对应参数jclass，因为静态方法不依赖对象实例，而依赖于类，所以参数中传递的是一个jclass类型。相反，如果声明的Native方法时非静态方法时，那么对应参数是jobject 。
其在`<jni.h>`中的定义如下：

```cpp
typedef _jobject *jobject;
typedef _jclass *jclass;
...
class _jobject {};
class _jclass : public _jobject {};
...
```

为了能够在Native层访问Java中的类和对象，`jobject`和`jclass` 分别指代了其所指代的类和对象，进而访问成员方法和成员变量等。但其实，我们一般使用javah指令直接生成Native函数的函数原型，故而不必纠结该使用哪种类型。

### JNI生成日志

> 在Android-JNI-c++中，使用cout无法输出内容时，可以采用如下方法，注意日志等级

```cpp
#include <android/log.h>
// log标签

#define  TAG    "zhuque"

// 定义info信息

#define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG,__VA_ARGS__)

// 定义debug信息

#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__)

// 定义error信息

#define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__)

void func(){
    int x = 10;
    LOGD("I am in cpp now, %d !", x);
}
```

