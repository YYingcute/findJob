# C++各个单元思考题目

## 4、类和对象

数据成员定义的次序决定了初始化的次序。

对象注销时，系统自动调用析构函数，按成员在类中声明的次序逆序撤销成员，释放存储空间。

引用的导入：
　  参数传递的传值方式在函数域中为参数重新分配内存，而把实参的数值传递到新分配的内存中。它的优点是有效避免改变实参值。

[关于左值右值的概念](https://www.cnblogs.com/catch/p/3500678.html)

一般函数返回值时，要生成一个临时对象作为返回值的副本，而用引用作为返回值时，不生成值的副本。

采用引用返回方式时，返回的不能是函数中的局部变量，这时返回的局部变量地址已经失效。

复制构造函数的参数必须采用引用（why）。避免无穷递归。

CGood Car1("Peugeot 508"，30，98000.00);
//调用三个参数的构造函数
CGood Car2= Car1; //调用复制构造函数
Car2=Car1;    //调用重载的赋值操作符（后面介绍）
CGood Car3 ( Car1); 
//调用复制构造函数，Car1为实参
这样三个对象的初始化结果完全一样。

静态成员函数里只能访问静态数据成员。

1、利用关键字class和struct定义类的区别

回答：[区别](https://blog.csdn.net/weixin_39640298/article/details/84349171?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase)

2、多个构造函数，调用时选择哪一个？

回答：一般由系统自动判断用哪个构造函数,根据调用的方式来判断用哪一个，可以看做重载。

3、getName()是类的一个成员函数，执行str=mobile.getName() ; ， 此函数怎样就获取了mobile所在内存空间的数据 m_name的值？

回答：从this指针的角度。

4、构造函数可以在类中定义，也可以在类外定义，区别是什么？

区别仅仅在于编程的风格以及代码的可读性。
如果函数体过大，自然放在类定义的外边，不然影响代码的可读性。

5、什么时候需要必须自己重写析构函数？

C++默认版本的构造函数和析构函数只能对编译器分配的空间进行初始化和释放，自定义的构造函数和析构函数对用户分配的空间进行初始化和释放。各种的职责范围不同。比如当你的类数据成员中使用了动态分配的内存，你就需要定义自己的析构函数来释放这部分内存，防止内存泄露。

## 5、数组与指针

1： 数组不能作为一个整体进行访问和处理的，只能按元素进行个别的读写。

2：  C++数组第一个元素的下标为0，且下标表达方式是固定的fibon[i]; (i=0,1,..9)不做越界检测

3：数组元素在内存中是从低地址开始顺序排列，各元素的存储单元占用内存大小相同，各元素的存储单元之间没有空隙。

数组名可以作为函数的参数。在函数调用时传递实参数组的首地址，所以在被调函数中对形参数组的处理实际就是对调用函数的实参数组的处理。

C++只传递数组首地址，而对数组边界不加检查。如要指定长度可以设定另一个参数来传递数组元素的个数。

按对象的地址直接存取对象的方法称为“直接访问”方式。 
int c;       //对象c的地址：0X0109 	
c=10;    //直接访问
通过一个对象的地址来访问这个对象，称为“间接访问”方式。可以把对象的地址存放到一个指针对象（Pointer）里，如：
int *pc=&c;  //定义一个指针对象pc
*pc=20;       //间接访问，c的值被修改为20	
cout<<c<<endl;      //直接读取c
cout<<*pc<<endl;  //间接读取c的值

**引用和指针**

相同： 都可以间接访问另一个对象的内容
int i=20; int *pi=&i; int &ri=i;  *pi=10; ri=30; 
区别：

1. 引用总是指向某个对象，定义时必须初始化;   指针定义时可以不用初始化（引用强调安全但缺乏灵活，指针反之）
   int i=20; int *pi; int &ri=i; pi=&i; pi=0;
2. 赋值行为：引用修改关联对象的值，指针改变指向的对象。
   int ival=1024,ival2=2048;
   int *p1=&ival; 
   int &p2=ival;  p2=25;--->ival=25; //改变p2关联对象的值; 

指向一个固定对象的指针，即指针本身是常量，不能修改：
char ch='a',ch1='x';
char * const ptr=&ch;

//注意const放在类型说明*之后，变量名之前
*ptr='b'; //正确，变量ch的值被修改相当于ch='b';
ptr=&ch1; //错误
ptr本身在初始化时所指向的地址是不可改变的，但它指向的目标ch的值是可以改变的。

指向“const”对象的指针 (常量指针和指针常量说法混淆 p166)
   	 const char ch='A';
   	 const double * cp=&ch; 
即cp本身并不是const，可以修改指向别的const对象，但不能通过该指针修改对象.

1、当在类的外部访问该类的公有成员时，必须指明是哪一个对象。同一个类可以创建很多个对象，但它们共用同一份成员函数的代码。既然是同一份代码，那么成员函数又怎么知道是取哪一个对象的成员数据呢？

回答：当调用一个成员函数时，系统自动产生一个隐藏的指针，这个指针称为this指针，它始终指向产生这个调用的对象，并将该指针作为一个参数自动传递给该成员函数。

class X{ 
     int m_a;
     public: void fun(int val){    m_a=val;} 
};
X x1;     
x1.fun(10);    

1.成员函数内部通常省略this指针， 所访问的数据成员都是调用成员函数的对象的数据成员
  void X::fun(X * const this,int val){    this->m_a=val;}     x1.fun(10);

2.this指针是const指针,即不允许在成员函数内部指向其他对象

用指针访问数组：
 fib:数组第一个元素的地址;
*fib:数组的第一个元素fib[0]
总结：指针加1，则地址移动一个数组元素所占字节数。

字符串是用字符型数组存储的，字符串要求其尾部以'\0'作为结束标志。如：
char str[ ]="C++";        
sizeof (str)=4，而实际串本身长度为3个字节，多出来的一个就是串结束符'\0'。   

## 6、模板与数据结构

面性对象程序设计（OOP）三个核心：
1. 抽象(abstraction):数据和方法用类的形式进行封装
2. 继承(inheritance)：继承一个类的所有方法和属性
3. 多态(polymophism)：编译或者运行时决定调用那个函数

多态： 编译时(compile tme)多态和运行时(run time)多态 (静态绑定/动态绑定).

泛型编程：独立于任何特定类型的方式编写代码。简化程序代码的重要手段。

模板是建立通用的与数据类型无关的算法的重要手段，是泛型编程的基础

个人理解：模板是从代码实现的角度为某一类问题提供通用的代码解决方案。大大减轻了程序员的代码开发代价。

重点：编译时模板参数T被实例化，注意：函数模板不是普通函数，是具有特定操作的一类函数的设计框架。实例化后编译器会自动生成一个相应的具体函数（模板函数）

1、关键字 class和typename区别。 设计模板时要考虑数据类型。T虽然是通用类型，但要考虑能支持哪些类型？

[回答](https://blog.csdn.net/weixin_30244889/article/details/99473780)

## 7、动态内存分配与数据结构

操作系统为一个C++程序的运行所分配的内存分为四个区域

1. 自由存储区 (动态数据) 动态分配都在自由存储区(free store)/堆(heap)中进行。
2. 栈区（函数局部数据）
3. 全局数据区(全局、静态)
4. 代码区（程序代码）

标准字符串类string就是采用动态建立数组的方式解决数组溢出的问题的，例7.1所做的动态内存分配与释放，在string类对象中都是自动完成的，在程序中不需要也不允许再显式地为string进行动态内存的分配与释放。

动态分配数组的特点：

1. 变量n在编译时没有确定的值，而是在运行中输入，按运行时所需分配空间，这一点是动态分配的优点，可克服数组“大开小用”的弊端，在表、排序与查找中的算法，若用动态数组，通用性更佳。

2. 如果有char *pc=new char[10], *pc1，令pc1=pc，同样可用delete [ ] pc1 来释放该空间。

3. 没有初始化式（initializer），不可对数组初始化(error) (可以初始化为默认值，课本错误)。

   char *pc=new char[5]();// pc->数组元素具有默认值'/0'
   int *pi=new int[5](); //pi->数组元素具有默认值0 
   int *pi=new int[5];   //pi->数组元素随机值

动态内存分配技术使用的要点：

1. 动态分配失败。返回一个空指针（NULL）或抛出异常。堆资源不足。

2. 指针删除与自由存储区空间释放。删除一个指针p（delete p;）实际意思是删除了p所指的目标（变量或对象等），释放了它所占的自由存储区空间，而不是删除ｐ本身，释放自由存储区空间后，ｐ成了空悬指针/野指针。空悬指针是程序错误的一个根源）。建议这时将ｐ置空。int *p=new int(10);     delete p;      p=0;

3.  new()和delete()是可以重载的，它们都是类的静态成员函数。程序员无需显式声明它为静态的，系统自动定义为静态的。

4. 内存泄漏（memory leak）和重复释放。

   int *p=new int(0), *q, i;
   p=&i;	//代码有问题吗？p原来所指向的内存空间永远不能释放

   q=p; //q与q指向同一内存空间
   delete q; //回收q所指内存空间
   delete p; //回收p所指内存空间,已回收

   new与delete 是配对使用的， delete只能释放自由存储区空间。如果new返回的指针值丢失，则所分配的自由存储区空间无法回收，称内存泄漏，同一空间重复释放也是危险的，因为该空间可能已另分配，所以必须妥善保存new返回的指针，以保证不发生内存泄漏，也必须保证不会重复释放自由存储区内存空间。

5. 堆中对象的生命期

   从new操作开始到delete操作结束

   

**动态创建对象数组需要注意的地方：**
由自由存储区创建对象数组，只能调用默认的构造函数，不能调用其他任何构造函数。如果没有默认的构造函数，则不能创建对象数组

## 8、继承与多态

通过继承产生新的类，称派生类。继承呈现了面向对象程序设计的层次结构。体现了由简单到复杂的认识过程。通过继承机制，可以利用已有的数据类型来定义新的数据类型。所定义的新的数据类型不仅拥有新定义的成员，而且还同时拥有旧的成员。我们称已存在的用来派生新类的类为基类，又称为父类。由已存在的类派生出的新类称为派生类，又称为子类。

**多态指同一个实体同时具有多种形式。**它是面向对象程序设计（OOP）的一个重要特征。如果一个语言只支持类而不支持多态，只能说明它是基于对象的，而不是面向对象的。C++中的多态性具体体现在运行和编译两个方面。运行时多态是动态多态，其具体引用的对象在运行时才能确定。编译时多态是静态多态，在编译时就可以确定对象使用的形式。
多态：同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。在运行时，可以通过指向基类的指针，来调用实现派生类中的方法。

运行时的多态性是指在程序执行前，无法根据函数名和参数来确定该调用哪一个函数，必须在程序执行过程中，根据执行的具体情况来动态地确定。它是通过类继承关系和虚函数来实现的。目的也是建立一种通用的程序。通用性是程序追求的主要目标之一。

在最简单的情况下，一个类B继承类A或者从类A派生类B，通常将类A称为基类(父类)，类B称为派生类(子类)。这时，类B的对象具有类A对象的所有特性，甚至还会更多一些。也可以这样说，类B从类A派生出来。这意味着类B至少描述了与类A同样的接口，至少包含了同类A一样的数据，可以共享类A的成员函数。

protected: private 和public 的混合：

1. 不能在类的外面访问； 
2.  可以在派生类内部访问

多重继承：如果一个派生类可以同时有多个基类，称为多重继承（multiple-inheritance），这时的派生类同时得到了多个已有类的特征。
单继承：派生类只有一个直接基类的情况称为单继承（single-inheritance）。

直接参与派生出某类称为直接基类，而基类的基类，以及更深层的基类称为间接基类。

**编制派生类时可分四步**

1.吸收基类的成员  不论是数据成员，还是函数成员，除构造函数与析构函数外全盘接收 

2.发展新成员 派生类新成员必须与基类成员不同名，它的加入保证派生类在功能上有所发展。独有的新成员才是继承与派生的核心特征。

3.改造基类成员 声明一个和某基类成员同名的新成员,派生类中的新成员就屏蔽了基类同名成员称为同名覆盖（overriding）。派生类构造的一般过程，经验性的规则。 这一步通常利用虚函数的技术。新成员如是成员函数，参数表也必须一样，否则是重载。

4.重写构造函数与析构函数 派生类不继承这两种函数。不管原来的函数是否可用一律重写可免出错。

基类的private成员：只有基类和基类的友元能够访问，派生类及其他地方无权访问
基类的public和protected成员：派生类可直接访问
公有继承：基类的public为派生类public成员，基类的protected为派生类的protected成员
受保护继承：基类的public和protected为派生类protected成员
私有继承：基类的public和protected为派生类private成员

派生类对象的引用或指针可以自动转换为基类对象的引用或指针。但没有基类对象的引用或指针到派生类对象引用或指针的 自动转换。子类对象可以强制转换为父类或者赋值给父类,按父类来引用子类一般是正确的，这种转换叫做向上强制类型转换。如果说这种转换或者是赋值是直接在对象上进行操作的，那么会发生切割问题，原因是父类对象没有子类自己定义的附加功能。

派生类构造函数的定义：
派生类名::派生类名（参数列表）:基类名1（参数名表1）《，基类名2（参数名表2），……，基类名n（参数名表n）》，《成员对象名1（成员对象参数名表1），……，成员对象名m（成员对象参数名表m）》{
……//派生类新增成员的初始化；
} //所列出的成员对象名全部为新增成员对象的名字

1.在构造函数的声明中，冒号及冒号以后部分必须略去。
2.所谓不能继承并不是不能利用，而是把基类的构造函数作为新的构造函数的一部分，或者讲调用基类的构造函数。基类名仅指直接基类，写了底层基类，编译器认为出错。
3.冒号后的基类名，成员对象名的次序可以随意，这里的次序与调用次序无关。

![](https://note.youdao.com/yws/public/resource/3a0f04bd120995ed7cc98033b1d1b25a/xmlnote/WEBRESOURCE10a377d2ab5fb606dae4aa40e27f634d/158)

![](https://note.youdao.com/yws/public/resource/3a0f04bd120995ed7cc98033b1d1b25a/xmlnote/WEBRESOURCE44f63d3b75d5d47c5b7a7265d013a8ff/160)

派生类构造函数各部分执行次序： 
1.调用基类构造函数，按它们在派生类声明的先后顺序，顺序调用。 
2.调用成员对象的构造函数，按它们在类定义中声明的先后顺序，顺序调用。
3.派生类的构造函数体中的操作。

注意：
       在派生类构造函数中，只要基类不是使用无参的默认构造函数都要显式给出基类名和参数表。
       如果基类没有定义构造函数，则派生类也可以不定义，全部采用系统给定的默认构造函数。
       如果基类定义了带有形参表的构造函数时，派生类就应当定义构造函数。

析构函数的功能是作善后工作。
       只要在函数体内把派生类新增一般成员处理好就可以了，而对新增的成员对象和基类的善后工作，系统会自己调用成员对象和基类的析构函数来完成。
        析构函数各部分执行次序与构造函数相反，首先对派生类新增一般成员析构，然后对新增对象成员析构，最后对基类成员析构。

虚函数的概念：
虚函数是一个类的成员函数，定义格式如下：
virtual  返回类型  函数名（参数表）{…}；
关键字virtual指明该成员函数为虚函数。virtual仅用于成员函数的声明中，成员函数类外定义不可再加virtual。

当一个类的某个成员函数被定义为虚函数，则由该类派生出来的所有派生类中，该函数始终保持虚函数的特征。

如未加关键字virtual，则是普通的派生类中的新成员函数覆盖基类同名成员函数（当然参数表必须一样，否则是重载），可称为同名覆盖函数，它不能实现运行时的多态性。 

**触发动态绑定的两个要点：**

1. 只有指定为虚函数的成员才能进行动态绑定，成员函数默认为非虚函数，非虚函数不能进行动态绑定；

2.必须通过基类类型的引用或指针进行函数调用；

**成员函数设置为虚函数的要点：**

1.  派生类中定义虚函数必须与基类中的虚函数同名外，还必须同参数表，同返回类型。否则被认为是重载，而不是虚函数。如基类中返回基类指针（或引用），派生类中返回派生类指针（或引用）是允许的，这是一个例外。
2.  只有类的成员函数才能说明为虚函数。这是因为虚函数仅适用于有继承关系的类对象。
3.  静态成员函数，是所有同一类对象共有，不受限于某个对象，不能作为虚函数。

4.一个类对象的静态和动态构造是相同的，实现动态多态性时，必须使用基类类型的指针变量或引用，使该指针指向该基类的不同派生类的对象，并通过该指针指向虚函数，才能实现动态的多态性。

5.内联函数因为每个对象有独立的一份函数代码，无映射关系，不能作为虚函数。
6. 析构函数可定义为虚函数，构造函数不能定义虚函数，因为在调用构造函数时对象还没有完成实例化。在基类中及其派生类中都动态分配的内存空间时，必须把析构函数定义为虚函数，实现撤消对象时的多态性。

7.函数执行速度要稍慢一些。为了实现多态性，每一个派生类中均要保存相应虚函数的入口地址表，函数的调用机制也是间接实现。所以多态性总是要付出一定代价，但通用性是一个更高的目标(参考 Item24 More Effective C++)。

8.如果定义放在类外，virtual只能加在函数声明前面，不能（再）加在函数定义前面。正确的定义必须不包括virtual。

9.虚函数的基类版本和派生类版本如果带有默认值的形参，其默认值必须相同，否则出现异常

10.在派生类虚函数中如果调用基类版本，必须利用作用域标识符，否则，调用自身，导致无穷递归

11.成员函数为模板，不能声明为virtual

静态类型：在编译时可知的引用类型或指针类型
class Base;  Base *p; //指针p的静态类型为Base
动态类型：指针或引用所绑定的对象类型，仅运行时可知 class Derived:public Base; 
Derived d;   Base *p=&d; //指针p的动态类型为Derived

**抽象类：不能用来创建对象的类**

它用于这样的情况：定义一个基类时，会遇到无法定义基类中虚函数的具体实现，其实现依赖于不同的派生类
含有纯虚函数的基类是不能用来定义对象的。纯虚函数没有实现部分，不能产生对象，所以含有纯虚函数的类是抽象类。

**定义要点**

1  声明纯虚函数时，不能在类内部定义虚函数的实现部分，在类外部可以给出函数定义。
2     “=0”必须放在成员函数的声明语句中。
3     在派生类中必须有重新定义的纯虚函数的函数体，这样的派生类才能用来定义对象。

与基类同名的派生类数据成员将屏蔽对基类的直接访问

**如何确定继承中的函数调用**

1.首先确定函数调用的对象、指针或引用的静态类型
2.在该类中查找函数，如果找不到，在其直接基类中查找，以此沿着继承链向上查找，直到找到为止。 否则调用出错。
3.一旦找到，进行常规类型检查，判断函数调用是否合法
4.如果合法，查看该函数是否是虚函数且通过指针或引用调用，确定动态绑定版本。

